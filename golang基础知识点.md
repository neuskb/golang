# golang 基础知识点

1. 除了加mutex锁以外还有哪些方式可以安全的读写变量？
```
    goroutine可以通过channel进行安全读写变量
```

2. sturct能不能比较
```
    因为是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型
```

3. 内存逃逸，哪些场景会出现内存逃逸
```
   指针逃逸
   栈空间不足逃逸
   interface类型多态的时候
   闭包引用包外的值
   chan中发送数据的指针或者包含指针的值
   slice、map中存储指针或者包含指针的值
```

4. 协程、线程、进程区别
```
    进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

    线程
    线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

    协程
    协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
```

5.  defer是先进先出还是先进后出
```
    先进后出，后进先出
```

6. make和new有什么区别
```
    均是在堆上内存分配
    make只用于slice、map、channel的初始化（非零值），new用于类型的内存分配（内存置为零）
    make返回的是这三个引用类型本身，new返回的是指向类型的指针
    new不常用，一般均是直接使用如下方式new
```

7. sync.Map的底层实现
```
    sync.Map里头有两个map一个是专门用于读的read map，另一个是才是提供读写的dirty map；优先读read map，若不存在则加锁穿透读dirty map，同时记录一个未从read map读到的计数，当计数到达一定值，就将read map用dirty map进行覆盖。
```

8. 设计模式中的单例模式，在Golang中有哪些实现的方式
```
    sync.Once
```

9. goroutine调度机制
```
    GMP分别指什么？
    a. G代表一个goroutine对象，每次go调用的时候，都会创建一个G对象
    b. M代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行
    b. P代表一个处理器，每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样
```

10. map底层数据结构
```
    哈希，无序
```
11. grpc使用场景